# ✏MainApplication

## @SpringBootApplication

- 스프링 부트의 가장 기본적인 설정을 선언해줌
    
    ### @ComponentScan
    
    - @component 어노테이션 및 @Service, @Repository, @Controller 등의 어노테이션을 스캔하여 Bean으로 등록해주는 어노테이션
    
    ### @EnableAutoConfiguration
    
    - 사전에 정의한 라이브러리들을 Bean으로 등록해주는 어노테이션

## @EnableJpaAuditing

- 생성일자와 수정일자를 자동으로 등록해주는 어노테이션

# ✏Controller

## @RestController

- @Controller에 @ResponseBody가 추가된 것으로 주용도는 Json 형태로 객체 데이터를 반환하는것

## @RequestMapping

- 들어온 요청을 특정 메서드와 매핑하기 위해 사용하는 어노테이션
- method = RequestMethod.GET 와 같이 특정 method를 지정하여 사용할 수 있다.
- Class와 Method에 붙일 수 있다.

## @GetMapping, @PostMapping, @PutMapping, @DeleteMapping

- 들어온 요청을 특정 메서드와 매핑하기 위해 사용하는 어노테이션
- Method에만 붙일 수 있다.

## @ArgsConstructor

Lombok 어노테이션

- @AllArgsConstructor
    - 모든 필드 값을 파라미터로 받는 생성자 생성
- @NoArgsConstructor
    - 파라미터가 없는 기본 생성자 생성
- @RequiredArgsConstructor
    - final이나 @NonNull인 필드 값만 파라미터로 받는 생성자 생성

## @CrossOrigin

[https://velog.io/@modsiw/Spring-CrossOrigin-Annotation-정리](https://velog.io/@modsiw/Spring-CrossOrigin-Annotation-%EC%A0%95%EB%A6%AC)

- CORS(Cross Origin Resource sharing)을 스프링을 통해 설정할 수 있는 기능

- 특정 메소드만 필요할 경우 Method 위에 어노테이션 설정
- 클래스내 모든 메소드에 적용할 경우 Class 위에 어노테이션 설정

# ✏Dto

## @Data

Lombok 어노테이션

- @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor 를 합쳐놓은 종합 선물 세트
    
    ### @EqualsAndHashCode
    
    - equals, hashCode 자동 생성
    - equals : 두 객체의 내용이 같은지, 동등성을 비교하는 연산자
    - hashCode : 두 객체가 같은 객체인지, 동일성을 비교하는 연산자

# ✏Entity

# @ElementCollection

- RDB에서는 컬렉션(리스트, 셋)과 같은 형태의 데이터를 컬럼에 저장할 수 없기 때문에, 별도의 테이블을 생성하여 컬렉션을 관리해야 한다.
- 이때 컬렉션 객체임을 JPA에게 알려주는 어노테이션이 @ElementCollection이다.
- ElementCollection과 Entity의 OneToMany 차이점
    - ElementCollection
        - 연관된 부모 Entity 하나에만 연관되어 관리된다. (부모 Entity와 독립적으로 사용 X)
        - 항상 부모와 함께 저장되고 삭제되므로 cascade 옵션은 제공하지 않는다. (cascade = ALL 인셈)
        - 부모 Entity Id와 추가 컬럼(basic or embedded 타입)으로 구성된다.
        - 기본적으로 식별자 개념이 없으므로 컬렉션 값 변경 시, 전체 삭제 후 새로 추가한다.
    - Entity 연관 OneToMany
        - 다른 Entity에 의해 관리될 수도 있다.
        - join table이나 컬럼은 보통 ID 만으로 연관을 맺는다.
    - 차이점 결론
        - ElementCollection은 정말 단순한 경우에만 사용하는 것이 좋다.
        - 식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 엔티티로 사용하는 것이 좋다.

## @Id

- 기본 키 매핑을 위한 어노테이션

## @GeneratedValue

- 기본 키 자동 생성 전략(4가지)
    - IDENTITY
        - MySQL, PostgreSQL 등에서 사용
        - 기본 키 생성을 데이터베이스에 위임 (알아서 AUTO_INCREMENT 되게)
    - SEQUENCE
        - Oracle, H2 등에서 사용
        - 데이터베이스 Sequence Object 사용
            - Sequence Object : 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트
        - 결국 IDENTITY와 동일하게 알아서 AUTO_INCREMENT
    - TABLE
        - 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략
        - 모든 DB에 적용 가능하나 최적화 되어있지 않은 테이블을 직접 사용하기 때문에 성능이슈
    - AUTO
        - 기본 설정 값
        - 방언에 따라 위의 세가지 전략을 자동으로 지정한다.

## @Enumerated

- enum 타입임을 알려주는 어노테이션
- EnumType (ORDINAL vs STRING)
    - ORDINAL : enum 순서 값을 DB에 저장 ex) 1, 2
    - STRING : enum 이름을 DB에 저장 ex) 광주, 서울

# ✏Service

## @Transactional

- 선언적 트랜잭션을 사용하기 위해 붙이는 어노테이션
- 트랜잭션이란
    - 데이터베이스의 상태를 변경하는 작업 또는 한번에 수행되어야 하는 연산들을 의미
    - 트랜잭션의 4가지 성질
        - **원자성** - 한 트랜잭션 내에서 실행된 작업들은 하나의 단위로 처리한다.
        - **일관성** - 트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다.
        - **격리성** - 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야한다.
        - **영속성** - 트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.
- readOnly = true
    - 트랜잭션에 readOnly 옵션을 주면 강제로 플러시를 호출하지 않는 한 **플러시가 일어나지 않는다**.
    - 따라서 트랜잭션을 커밋하더라도 영속성 컨텍스트가 플러시 되지 않아서 엔티티의 등록, 수정, 삭제가 동작하지 않고, 또한 읽기 전용으로 영속성 컨텍스트는 변경 감지를 위한 스냅샷을 보관하지 않으므로 성능이 향상된다.

## @Autowired

- IoC 컨테이너에 등록되어 있는 빈의 의존성을 주입하기 위한 어노테이션
- 의존성 주입의 종류
    - 생성자 주입 (권장)
        - final을 선언하여 객체가 임의로 변하는 것을 막을 수 있다.
        - 순환 참조가 발생하는 경우 애플리케이션이 구동하지 않아 오류를 방지할 수 있다.
    - 필드 주입
    - setter 주입 (비추)